1.Parent and child process 
  Write a C/CPP program to create a child process. Child should print its pid and its 
   parent’s pid and should exit by printing message as “Child Exiting …”. 
   Parent should print its pid and should exit by printing message as “Parent Exiting ..”. 
  (Hint(functions to be used) : getpid, fork, getppid) 

->  #include <stdio.h>            
#include <stdlib.h>                  
#include <unistd.h>   
#include <sys/wait.h>                
int main(void) 
{
  int i, pid;
  pid = getpid();
  printf("parent pid = %d\n", pid);
  
  pid = fork();
  if (pid == 0) /* child process is always 0 
  {
    for (i = 0; i < 10; i++) 
    {
      printf("child process: %d\n",i);
      sleep(1); 
    }
    printf("child exiting\n");
    exit(0);
  }
  else 
  { 
    printf("child pid = %d\n", pid);
    printf("waiting for child\n");
    wait(NULL);
    printf("child terminated\n"); 
  }
  printf("parent exiting\n");
  
  return 0;
}


2. Write a program in C/CPP to check the scheduling policy used by the process and its priority. 

#include<stdio.h>
 
int main()
{
    int bt[20],p[20],wt[20],tat[20],pr[20],i,j,n,total=0,pos,temp,avg_wt,avg_tat;
    printf("Enter Total Number of Process:");
    scanf("%d",&n);
 
    printf("\nEnter Burst Time and Priority\n");
    for(i=0;i<n;i++)
    {
        printf("\nP[%d]\n",i+1);
        printf("Burst Time:");
        scanf("%d",&bt[i]);
        printf("Priority:");
        scanf("%d",&pr[i]);
        p[i]=i+1;           //contains process number
    }
 
    //sorting burst time, priority and process number in ascending order using selection sort
    for(i=0;i<n;i++)
    {
        pos=i;
        for(j=i+1;j<n;j++)
        {
            if(pr[j]<pr[pos])
                pos=j;
        }
 
        temp=pr[i];
        pr[i]=pr[pos];
        pr[pos]=temp;
 
        temp=bt[i];
        bt[i]=bt[pos];
        bt[pos]=temp;
 
        temp=p[i];
        p[i]=p[pos];
        p[pos]=temp;
    }
 
    wt[0]=0;	//waiting time for first process is zero
 
    //calculate waiting time
    for(i=1;i<n;i++)
    {
        wt[i]=0;
        for(j=0;j<i;j++)
            wt[i]+=bt[j];
 
        total+=wt[i];
    }
 
    avg_wt=total/n;      //average waiting time
    total=0;
 
    printf("\nProcess\t    Burst Time    \tWaiting Time\tTurnaround Time");
    for(i=0;i<n;i++)
    {
        tat[i]=bt[i]+wt[i];     //calculate turnaround time
        total+=tat[i];
        printf("\nP[%d]\t\t  %d\t\t    %d\t\t\t%d",p[i],bt[i],wt[i],tat[i]);
    }
 
    avg_tat=total/n;     //average turnaround time
    printf("\n\nAverage Waiting Time=%d",avg_wt);
    printf("\nAverage Turnaround Time=%d\n",avg_tat);
 
	return 0;
}  


3 Scheduling functions 
  Write a program in C/CPP to get the current scheduling policy of the process. The program should change the scheduling policy to the other than current one. Program should report errors if it fails to set the new scheduling policy. 
  (Hint(functions to be used) : sched_setscheduler, getpid) 

-> #include<iostream> 
using namespace std; 
  
// Function to find the waiting time for all 
// processes 
void findWaitingTime(int processes[], int n, 
             int bt[], int wt[], int quantum) 
{ 
    // Make a copy of burst times bt[] to store remaining 
    // burst times. 
    int rem_bt[n]; 
    for (int i = 0 ; i < n ; i++) 
        rem_bt[i] =  bt[i]; 
  
    int t = 0; // Current time 
  
    // Keep traversing processes in round robin manner 
    // until all of them are not done. 
    while (1) 
    { 
        bool done = true; 
  
        // Traverse all processes one by one repeatedly 
        for (int i = 0 ; i < n; i++) 
        { 
            // If burst time of a process is greater than 0 
            // then only need to process further 
            if (rem_bt[i] > 0) 
            { 
                done = false; // There is a pending process 
  
                if (rem_bt[i] > quantum) 
                { 
                    // Increase the value of t i.e. shows 
                    // how much time a process has been processed 
                    t += quantum; 
  
                    // Decrease the burst_time of current process 
                    // by quantum 
                    rem_bt[i] -= quantum; 
                } 
  
                // If burst time is smaller than or equal to 
                // quantum. Last cycle for this process 
                else
                { 
                    // Increase the value of t i.e. shows 
                    // how much time a process has been processed 
                    t = t + rem_bt[i]; 
  
                    // Waiting time is current time minus time 
                    // used by this process 
                    wt[i] = t - bt[i]; 
  
                    // As the process gets fully executed 
                    // make its remaining burst time = 0 
                    rem_bt[i] = 0; 
                } 
            } 
        } 
  
        // If all processes are done 
        if (done == true) 
          break; 
    } 
} 

void findTurnAroundTime(int processes[], int n, 
                        int bt[], int wt[], int tat[]) 
{ 
    // bt[i] + wt[i] 
    for (int i = 0; i < n ; i++) 
        tat[i] = bt[i] + wt[i]; 
} 
  

void findavgTime(int processes[], int n, int bt[], 
                                     int quantum) 
{ 
    int wt[n], tat[n], total_wt = 0, total_tat = 0; 
  
    findWaitingTime(processes, n, bt, wt, quantum); 
  
 
    findTurnAroundTime(processes, n, bt, wt, tat); 
  
    
    cout << "Processes "<< " Burst time "
         << " Waiting time " << " Turn around time\n"; 
  
   
    for (int i=0; i<n; i++) 
    { 
        total_wt = total_wt + wt[i]; 
        total_tat = total_tat + tat[i]; 
        cout << " " << i+1 << "\t\t" << bt[i] <<"\t "
             << wt[i] <<"\t\t " << tat[i] <<endl; 
    } 
  
    cout << "Average waiting time = "
         << (float)total_wt / (float)n; 
    cout << "\nAverage turn around time = "
         << (float)total_tat / (float)n; 
} 
  

int main() 
{ 

    int processes[] = { 1, 2, 3}; 
    int n = sizeof processes / sizeof processes[0]; 
  
 
    int burst_time[] = {10, 5, 8}; 
  

    int quantum = 2; 
    findavgTime(processes, n, burst_time, quantum); 
    return 0; 
} 
